<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://trylovecatch.github.io">
  <title>测量（Measure） | TryLoveCatch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这篇文章，主要介绍一下自定义View和自定义ViewGroup中的onMeasure用法，下面进入正题。">
<meta property="og:type" content="article">
<meta property="og:title" content="测量（Measure）">
<meta property="og:url" content="http://trylovecatch.github.io/2016/12/04/custom-view-measure/index.html">
<meta property="og:site_name" content="TryLoveCatch">
<meta property="og:description" content="这篇文章，主要介绍一下自定义View和自定义ViewGroup中的onMeasure用法，下面进入正题。">
<meta property="og:image" content="http://og9cdbtvi.bkt.clouddn.com/activity_root_view.png">
<meta property="og:image" content="http://og9cdbtvi.bkt.clouddn.com/getChildMeasureSpec.jpg">
<meta property="og:image" content="http://og9cdbtvi.bkt.clouddn.com/layout.png">
<meta property="og:updated_time" content="2016-12-04T07:48:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="测量（Measure）">
<meta name="twitter:description" content="这篇文章，主要介绍一下自定义View和自定义ViewGroup中的onMeasure用法，下面进入正题。">
<meta name="twitter:image" content="http://og9cdbtvi.bkt.clouddn.com/activity_root_view.png">
  
    <link rel="alternative" href="/atom.xml" title="TryLoveCatch" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/favicon.ico">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">TryLoveCatch</a></h1>
		</hgroup>

		
		<p class="header-subtitle">学习是一种信仰</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/poem">诗词</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/TryLoveCatch" title="github"><i class="icon-github"></i></a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss"><i class="icon-rss"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">TryLoveCatch</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/assets/avatar.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">TryLoveCatch</h1>
			</hgroup>
			
			<p class="header-subtitle">学习是一种信仰</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/poem">诗词</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TryLoveCatch" title="github"><i class="icon-github"></i></a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss"><i class="icon-rss"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-custom-view-measure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      测量（Measure）
    </h1>
  

        <a href="/2016/12/04/custom-view-measure/" class="archive-article-date">
  	<time datetime="2016-12-04T07:09:51.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-04</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  这篇文章，主要介绍一下自定义View和自定义ViewGroup中的onMeasure用法，下面进入正题。<br><a id="more"></a></p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们举个例子：</p>
<p>一个简单的自定义View<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImgView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Bitmap mBitmap;<span class="comment">// 位图对象  </span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImgView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 绘制位图  </span></div><div class="line">        canvas.drawBitmap(mBitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, </span></span></div><div class="line">        <span class="keyword">int</span> heightMeasureSpec) &#123;  </div><div class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);  </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 设置位图 </div><div class="line">     *  </div><div class="line">     * <span class="doctag">@param</span> bitmap </div><div class="line">     *            位图对象 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBitmap</span><span class="params">(Bitmap bitmap)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.mBitmap = bitmap;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:background</span>=<span class="string">"#FFFFFFFF"</span>  </div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">com.test.views.ImgView</span>  </span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/main_pv"</span>  </div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">Button</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"AigeStudio"</span> /&gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"AigeStudio"</span> /&gt;  </div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个例子运行后，我们会发现，无论ImgView的width、height是match_parent，还是wrap_content，button和textview都不会显示在屏幕上。这个就跟view的测量机制有关系了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, </span></span></div><div class="line">    <span class="keyword">int</span> heightMeasureSpec) &#123;  </div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果自定义一个View，onMeasure方法默认就是上面这种写法，直接将参数传给父类view，此方法中的两个参数是谁传过来的呢？答案，都是父布局传过来，这个例子中是由LinearLayout传过来的，那么LinearLayout里面的又是谁传进来的呢？这里我们就需要知道根布局这个概念了。</p>
<h2 id="根布局"><a href="#根布局" class="headerlink" title="根布局"></a>根布局</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">    setContentView(R.layout.activity_main);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;setContentView是我们会在自己写的Activity里面调用的，而在Activity源码里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;  </div><div class="line">    getWindow().setContentView(layoutResID);  </div><div class="line">    initActionBar();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;getWindow()会返回一个继承Window的PhoneWindow(TV的话，会是TVWindow)，然后执行它的setContentView()，而如下所示，PhoneWindow是在Activity的attach()中通过makeNewWindow生成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,  </span></span></div><div class="line">    // 此处省去一些代码……  </div><div class="line">  </div><div class="line">    mWindow = PolicyManager.makeNewWindow(<span class="keyword">this</span>);  </div><div class="line">    mWindow.setCallback(<span class="keyword">this</span>);  </div><div class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);  </div><div class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;  </div><div class="line">        mWindow.setSoftInputMode(info.softInputMode);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;  </div><div class="line">        mWindow.setUiOptions(info.uiOptions);  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">// 此处省去巨量代码……  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;PolicyManager通过反射得到了Policy，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyManager</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POLICY_IMPL_CLASS_NAME =  </div><div class="line">        <span class="string">"com.android.internal.policy.impl.Policy"</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IPolicy sPolicy;  </div><div class="line">  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME);  </div><div class="line">            sPolicy = (IPolicy)policyClass.newInstance();  </div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(  </div><div class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be loaded"</span>, ex);  </div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(  </div><div class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be instantiated"</span>, ex);  </div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(  </div><div class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be instantiated"</span>, ex);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 省去构造方法……  </span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> sPolicy.makeNewWindow(context);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 省去无关代码……  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Policy中的makeNewWindow()直接返回了一个PhoneWindow<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PhoneWindow(context);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面就说到了，上面提的setContentView()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">MenuBuilder</span>.<span class="title">Callback</span> </span>&#123;  </div><div class="line">    <span class="comment">// 省去代码……  </span></div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;  </div><div class="line">            installDecor();  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            mContentParent.removeAllViews();  </div><div class="line">        &#125;  </div><div class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);  </div><div class="line">        <span class="keyword">final</span> Callback cb = getCallback();  </div><div class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;  </div><div class="line">            cb.onContentChanged();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 省去代码……  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个源码，我们可以看出来，就是将我们自己传进来的layoutId，添加到mContentParent下面，而这个mContentParent是在installDecor()里面赋值的，首先会初始化成员变量DecorView类的mDecor，然后调用generateLayout()，传入DecorView，来得到mContentParent。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;  </div><div class="line">        mDecor = generateDecor();  </div><div class="line">        <span class="comment">//  省省省……  </span></div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;  </div><div class="line">        mContentParent = generateLayout(mDecor);  </div><div class="line">  </div><div class="line">        <span class="comment">//  省省省……  </span></div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">//  省省省……  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 省去巨量代码……  </span></div><div class="line">  </div><div class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);  </div><div class="line">  </div><div class="line">    <span class="comment">// 省去一些代码……  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在generateLayout()中，会根据不同的Style类型来选择不同的布局文件，然后会add进DecorView中，然后调用findViewById()从DecorView里面得到mContentParent，这个才是真正的根布局，一般情况下，根布局都是FrameLayout来担任，我们可以用xml的最顶层viewGroup调用getParent()，返回的就是FrameLayout对象，其id是android:id=”@android:id/content”。</p>
<p>所以，<font color="#ff0000">一个Activity，里面是PhoneWindow，然后是DecorView，这个DecorView继承自FrameLayout，最后，才是我们自己setContentView的布局</font></p>
<p><img src="http://og9cdbtvi.bkt.clouddn.com/activity_root_view.png" alt=""></p>
<h2 id="VSYNC"><a href="#VSYNC" class="headerlink" title="VSYNC"></a>VSYNC</h2><p>接下来，View就显示出来了么？我们熟知的 onMeasure、onLayout 和 onDraw都还没有调用呢？看起来，我们需要一个时机来触发 View 的操作。<br>这个就得说下垂直同步机制(VSYNC)：</p>
<blockquote>
<p>VSYNC 就是一种同步机制，以某种固定的频率进行同步，当其他组件收到这个同步信号时，就执行相应的操作。设想一下，如果没有这个同步机制，各个模块又怎能知道在哪个时候去执行自己的工作了？ 这里可以初步地将 VSYNC 当做闹钟，每间隔固定时间，就响一次，其他组件听到闹铃后，就开始干活了。这个间隔的时间，与屏幕刷新频率有关，例如大多数 Android 设备的刷新频率是 60 FPS(Frame per second)，一秒钟刷新60次，因而间隔时间就是 1000 / 60 = 16.667 ms。这个时间，大家是不是很熟悉了？看过太多性能优化的文章，都说每一帧的绘制时间不要超过 16 ms，其背后的原因就是这个。绘制每一帧对应的 View，这个步骤发生在 UI 线程上，所以也不要在 UI 线程上进行耗时的操作，否则就可能在 16 ms内，无法完成界面更新操作了。</p>
</blockquote>
<p>长话短说，总结一下，当 Choreographer 接收到 VSYNC 信号后，ViewRootImpl 调用 scheduleTraversals 方法，通知 View 进行相应的渲染，其后 ViewRootImpl 将 View 添加或更新到 Window 上去，并会执行TraversalRunnable 的doTraversal()，会调用到 performTraversals()，这是一个非常长的方法，里面就会提到我们熟悉的Measure、Layout 和 Draw。</p>
<h2 id="Measure"><a href="#Measure" class="headerlink" title="Measure"></a>Measure</h2><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>下面会用到MeasureSpec，我们提前介绍下</p>
<blockquote>
<p>MeasureSpec 是什么，这里是利用了位运算，将一个 int 类型包含了两种信息，分别是 size 和 mode。java 的 int 类型，可以表示 32 位数字，最高的两位数字用来表示 mode，其余的部分用来表示 size。对于手机屏幕而言，size 一般都有限，不用担心需要 31 位数字来表达 size 的情况。</p>
</blockquote>
<p>MeasureSpec 分别有三种 mode，分别是 UNSPECIFIED, EXACTLY 和 AT_MOST.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div></pre></td></tr></table></figure></p>
<p>UNSPECIFIED: 标明自身对 View 大小没有任何限制，需要子 View 的信息来帮助协定</p>
<p>EXACTLY: View 已经确定自身的大小</p>
<p>AT_MOST: 父 View 已经限定了最大大小，具体 View 能不能超过这个限制，得看不同 View 的实现情况。</p>
<p>而对于 Size 而言，就是具体的数值大小了。Android 提供了生成 MeasureSpec 的静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">        <span class="keyword">return</span> size + mode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="根布局的MeasureSpec"><a href="#根布局的MeasureSpec" class="headerlink" title="根布局的MeasureSpec"></a>根布局的MeasureSpec</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="comment">// ………省略宇宙尘埃数量那么多的代码………  </span></div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (!mStopped) &#123;  </div><div class="line">        <span class="comment">// ……省略一些代码  </span></div><div class="line">  </div><div class="line">        <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);  </div><div class="line">        <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);  </div><div class="line">  </div><div class="line">        <span class="comment">// ……省省省  </span></div><div class="line">  </div><div class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// ………省略人体细胞数量那么多的代码………  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> measureSpec;</div><div class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> measureSpec;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面代码可以看出来，DecorView的大小，取决于Window的大小和WindowManager.LayoutParams，接下来看看 windowSize， rootDimension 是怎么赋值的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</div><div class="line">    type = TYPE_APPLICATION;</div><div class="line">    format = PixelFormat.OPAQUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中lp.width和lp.height均为MATCH_PARENT，其在mWindowAttributes（WindowManager.LayoutParams类型）将值赋予给lp时就已被确定，mWidth和mHeight表示当前窗口的大小，其值由performTraversals中一系列逻辑计算确定。<br>所以就是，window 的 LayoutParams 就是 MATCH_PARENT, 这样 DecorView 的大小就是 Window 的大小，也就是必定是全屏的。</p>
<p>接着看最开始代码中 performMeasure 的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</div><div class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码终于执行到measure()了</p>
<h3 id="measure-和onMeasure"><a href="#measure-和onMeasure" class="headerlink" title="measure()和onMeasure()"></a>measure()和onMeasure()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></div><div class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</div><div class="line">                    mMeasureCache.indexOfKey(key);</div><div class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</div><div class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></div><div class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></div><div class="line">            <span class="comment">// an exception to warn the developer</span></div><div class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></div><div class="line">                        + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></div><div class="line">                        + <span class="string">" measured dimension by calling"</span></div><div class="line">                        + <span class="string">" setMeasuredDimension()"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到measure()是final方法，因为这个measure是view的重要流程，所以不能复写，代码中调用了onMeasure()，这个方法中，一定要指定MeasureSpec，不然就不知道view的大小了。</p>
<p>默认的onMeasure实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getSuggestedMinimumWidth()，如果背景为空，那么我们直接返回mMinWidth最小宽度，否则，就在mMinWidth和背景最小宽度之间取一个最大值，getSuggestedMinimumHeight类同，mMinWidth和mMinHeight我没记错的话应该都是100px。<br>getDefaultSize()中，当模式为AT_MOST和EXACTLY时均会返回解算出的测量尺寸，也就是说，上面我们说的PhoneWindow、DecorView么从它们那里获取到的测量规格层层传递到我们的自定义View中，这也解释了文章一开始那个例子，为什么我们的View在默认情况下不管是math_parent还是warp_content都能占满父容器的剩余空间。</p>
<h3 id="自定义View的onMeasure"><a href="#自定义View的onMeasure" class="headerlink" title="自定义View的onMeasure"></a>自定义View的onMeasure</h3><p>所以，我们可以自己重写onMeasure实现自己的测量逻辑，修改我们ImgView中的onMeasure()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 设置测量尺寸  </span></div><div class="line">    setMeasuredDimension(<span class="number">250</span>, <span class="number">250</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单粗暴的直接设置长宽都为250px，当然，这样不好，用Android官方的话来说就是太过“专政”，<strong>因为它完全摒弃了父容器的意愿，完全由自己决定了大小。</strong></p>
<p>这个时候就需要上面说的MeasureSpec了，根据它的mode来判断，父容器的意图。再次修改我们的onMeasure()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 声明一个临时变量来存储计算出的测量值  </span></div><div class="line">    <span class="keyword">int</span> resultWidth = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">// 获取宽度测量规格中的mode  </span></div><div class="line">    <span class="keyword">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);  </div><div class="line">  </div><div class="line">    <span class="comment">// 获取宽度测量规格中的size  </span></div><div class="line">    <span class="keyword">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果爹心里有数 </div><div class="line">     */  </div><div class="line">    <span class="keyword">if</span> (modeWidth == MeasureSpec.EXACTLY) &#123;  </div><div class="line">        <span class="comment">// 那么儿子也不要让爹难做就取爹给的大小吧  </span></div><div class="line">        resultWidth = sizeWidth;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果爹心里没数 </div><div class="line">     */  </div><div class="line">    <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="comment">// 那么儿子可要自己看看自己需要多大了  </span></div><div class="line">        resultWidth = mBitmap.getWidth();  </div><div class="line">  </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 如果爹给儿子的是一个限制值 </div><div class="line">         */  </div><div class="line">        <span class="keyword">if</span> (modeWidth == MeasureSpec.AT_MOST) &#123;  </div><div class="line">            <span class="comment">// 那么儿子自己的需求就要跟爹的限制比比看谁小要谁  </span></div><div class="line">            resultWidth = Math.min(resultWidth, sizeWidth);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> resultHeight = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);  </div><div class="line">    <span class="keyword">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (modeHeight == MeasureSpec.EXACTLY) &#123;  </div><div class="line">        resultHeight = sizeHeight;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        resultHeight = mBitmap.getHeight();  </div><div class="line">        <span class="keyword">if</span> (modeHeight == MeasureSpec.AT_MOST) &#123;  </div><div class="line">            resultHeight = Math.min(resultHeight, sizeHeight);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 设置测量尺寸  </span></div><div class="line">    setMeasuredDimension(resultWidth, resultHeight);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们从父容器传来的MeasureSpec中分离出了mode和size，size只是一个期望值，我们需要根据mode来计算最终的size，如果父容器对子元素没有一个确切的大小，那么我们就需要尝试去计算我们自定义View的大小，而这部分大小，更多的是由我们，也就是开发者，去根据实际情况计算的，这里我们模拟的是一个显示图片的控件，那么控件的实际大小就应该跟我们的图片一致，即使我们可以做出一定的决定，也必须要考虑父容器的限制值，当mode为AT_MOST时，size则是父容器给予我们的一个最大值，我们控件的大小就不应该超过这个值。</p>
<h3 id="自定义View的padding"><a href="#自定义View的padding" class="headerlink" title="自定义View的padding"></a>自定义View的padding</h3><p>如上所说，控件的实际大小需要根据我们的实际需求去计算，这里我更改一下xml为我们的ImgView加一个内边距值：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  </div><div class="line">    android:layout_width="match_parent"  </div><div class="line">    android:layout_height="match_parent"  </div><div class="line">    android:background="#FFFFFFFF"  </div><div class="line">    android:orientation="vertical" &gt;  </div><div class="line">  </div><div class="line">    &lt;com.aigestudio.customviewdemo.views.ImgView  </div><div class="line">        android:id="@+id/main_pv"  </div><div class="line">        android:layout_width="wrap_content"  </div><div class="line">        android:layout_height="wrap_content"  </div><div class="line">        android:padding="20dp" /&gt;  </div><div class="line">  </div><div class="line">    &lt;Button  </div><div class="line">        android:layout_width="wrap_content"  </div><div class="line">        android:layout_height="wrap_content"  </div><div class="line">        android:text="AigeStudio" /&gt;  </div><div class="line">  </div><div class="line">    &lt;TextView  </div><div class="line">        android:layout_width="wrap_content"  </div><div class="line">        android:layout_height="wrap_content"  </div><div class="line">        android:text="AigeStudio" /&gt;  </div><div class="line">  </div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>这时候运行，我们会发现，图片毫无内边距效果，因为我们的宽高，并没有考虑内边距的大小，所以予以修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">resultWidth = mBitmap.getWidth() + getPaddingLeft() + getPaddingRight();  </div><div class="line">resultHeight = mBitmap.getHeight() + getPaddingTop() + getPaddingBottom();</div></pre></td></tr></table></figure></p>
<p>但是，你运行之后，会发现，左右可以了，但是上下没有边距，这个是因为我们drawBitmap的时候没有考虑边距：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 绘制位图  </span></div><div class="line">    canvas.drawBitmap(mBitmap, getPaddingLeft(), getPaddingTop(), <span class="keyword">null</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行一下，完美，哈哈哈。</p>
<h3 id="自定义View的margin"><a href="#自定义View的margin" class="headerlink" title="自定义View的margin"></a>自定义View的margin</h3><font color="#ff0000"><strong>一句话，外边距轮不到view来算，Andorid将其封装在LayoutParams内交由父容器统一处理。</strong></font>

<h3 id="父容器"><a href="#父容器" class="headerlink" title="父容器"></a>父容器</h3><p>ViewGroup继承自View，没有重写onMeasure()，只是提供了几个方法供子类实现，但是在在子类里面(例如LinearLayout)都重写了onMeasure()，并调用了父类提供的这几个方法。</p>
<p>measureChildren</p>
<blockquote>
<p>measureChildren 对所有可见 view 调用 measureChild 方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;  </div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;  </div><div class="line">        <span class="keyword">final</span> View child = children[i];  </div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;  </div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>measureChildWithMargins</p>
<blockquote>
<p>measureChildWithMargins要求 child 进行 Measure，在绘制的时候将自己的 padding 和 margins 考虑进去。经过 Measure 过后，可以得到对应的 LayoutParams 这个方法要求 child 必须得是 MarginLayoutParams，大部分的容器 View (LinearLayout、FrameLayout等等)都是这个 MarginLayoutParams。</p>
</blockquote>
<p>measureChild</p>
<blockquote>
<p>measureChild 这个方法与前面这个是相对的，不同之处在于只考虑自身的 padding，不考虑 margin。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,  </span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;  </div><div class="line">    <span class="comment">// 获取子元素的布局参数  </span></div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 将父容器的测量规格已经上下和左右的边距还有子元素本身的布局参数传入getChildMeasureSpec方法计算最终测量规格 </div><div class="line">     */  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,  </div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,  </div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);  </div><div class="line">  </div><div class="line">    <span class="comment">// 调用子元素的measure传入计算好的测量规格  </span></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>getChildMeasureSpec，非常重要的方法</strong></p>
<blockquote>
<p>getChildMeasureSpec 这个是上述方法都会调用的方法，分别有三个参数，父view的measureSpec, 父view 的 padding(或者加上margin), 子 view 期望的大小(不一定会实现)。 方法根据特定的规则来返回对应的 MeasureSpec，这是飞虫重要的一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 获取父容器的测量模式和尺寸大小  </span></div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);  </div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);  </div><div class="line">  </div><div class="line">    <span class="comment">// 这个尺寸应该减去内边距的值  </span></div><div class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);  </div><div class="line">  </div><div class="line">    <span class="comment">// 声明临时变量存值  </span></div><div class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 根据模式判断 </div><div class="line">     */  </div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;  </div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY: <span class="comment">// 父容器尺寸大小是一个确定的值  </span></div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 根据子元素的布局参数判断 </div><div class="line">         */  </div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123; <span class="comment">//如果childDimension是一个具体的值  </span></div><div class="line">            <span class="comment">// 那么就将该值作为结果  </span></div><div class="line">            resultSize = childDimension;  </div><div class="line">  </div><div class="line">            <span class="comment">// 而这个值也是被确定的  </span></div><div class="line">            resultMode = MeasureSpec.EXACTLY;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123; <span class="comment">//如果子元素的布局参数为MATCH_PARENT  </span></div><div class="line">            <span class="comment">// 那么就将父容器的大小作为结果  </span></div><div class="line">            resultSize = size;  </div><div class="line">  </div><div class="line">            <span class="comment">// 因为父容器的大小是被确定的所以子元素大小也是可以被确定的  </span></div><div class="line">            resultMode = MeasureSpec.EXACTLY;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123; <span class="comment">//如果子元素的布局参数为WRAP_CONTENT  </span></div><div class="line">            <span class="comment">// 那么就将父容器的大小作为结果  </span></div><div class="line">            resultSize = size;  </div><div class="line">  </div><div class="line">            <span class="comment">// 但是子元素的大小包裹了其内容后不能超过父容器  </span></div><div class="line">            resultMode = MeasureSpec.AT_MOST;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST: <span class="comment">// 父容器尺寸大小拥有一个限制值  </span></div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 根据子元素的布局参数判断 </div><div class="line">         */  </div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123; <span class="comment">//如果childDimension是一个具体的值  </span></div><div class="line">            <span class="comment">// 那么就将该值作为结果  </span></div><div class="line">            resultSize = childDimension;  </div><div class="line">  </div><div class="line">            <span class="comment">// 而这个值也是被确定的  </span></div><div class="line">            resultMode = MeasureSpec.EXACTLY;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123; <span class="comment">//如果子元素的布局参数为MATCH_PARENT  </span></div><div class="line">            <span class="comment">// 那么就将父容器的大小作为结果  </span></div><div class="line">            resultSize = size;  </div><div class="line">  </div><div class="line">            <span class="comment">// 因为父容器的大小是受到限制值的限制所以子元素的大小也应该受到父容器的限制  </span></div><div class="line">            resultMode = MeasureSpec.AT_MOST;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123; <span class="comment">//如果子元素的布局参数为WRAP_CONTENT  </span></div><div class="line">            <span class="comment">// 那么就将父容器的大小作为结果  </span></div><div class="line">            resultSize = size;  </div><div class="line">  </div><div class="line">            <span class="comment">// 但是子元素的大小包裹了其内容后不能超过父容器  </span></div><div class="line">            resultMode = MeasureSpec.AT_MOST;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED: <span class="comment">// 父容器尺寸大小未受限制  </span></div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 根据子元素的布局参数判断 </div><div class="line">         */  </div><div class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123; <span class="comment">//如果childDimension是一个具体的值  </span></div><div class="line">            <span class="comment">// 那么就将该值作为结果  </span></div><div class="line">            resultSize = childDimension;  </div><div class="line">  </div><div class="line">            <span class="comment">// 而这个值也是被确定的  </span></div><div class="line">            resultMode = MeasureSpec.EXACTLY;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123; <span class="comment">//如果子元素的布局参数为MATCH_PARENT  </span></div><div class="line">            <span class="comment">// 因为父容器的大小不受限制而对子元素来说也可以是任意大小所以不指定也不限制子元素的大小  </span></div><div class="line">            resultSize = <span class="number">0</span>;  </div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123; <span class="comment">//如果子元素的布局参数为WRAP_CONTENT  </span></div><div class="line">            <span class="comment">// 因为父容器的大小不受限制而对子元素来说也可以是任意大小所以不指定也不限制子元素的大小  </span></div><div class="line">            resultSize = <span class="number">0</span>;  </div><div class="line">            resultMode = MeasureSpec.UNSPECIFIED;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 返回封装后的测量规格  </span></div><div class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的代码，更直观点就如下图：<br><img src="http://og9cdbtvi.bkt.clouddn.com/getChildMeasureSpec.jpg" alt="img"></p>
<font color="#ff0000"><strong>通过上面这几个方法，我们知道，父View会根据自身的measureSpec和子View的LayoutParams来确定子View期望的measureSpec，并传到子View的measure()</strong></font>

<h3 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h3><p>我们自定义view的时候，最外层是一个LinearLayout，我们现在来自己实现一个简单的LinearLayout。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);  </div><div class="line">  </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 如果有子元素 </div><div class="line">         */  </div><div class="line">        <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="comment">// 那么对子元素进行测量  </span></div><div class="line">            measureChildren(widthMeasureSpec, heightMeasureSpec);  </div><div class="line">        &#125;  </div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;  </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 如果有子元素 </div><div class="line">         */  </div><div class="line">        <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="comment">// 声明一个临时变量存储高度倍增值  </span></div><div class="line">            <span class="keyword">int</span> mutilHeight = <span class="number">0</span>;  </div><div class="line">      </div><div class="line">            <span class="comment">// 那么遍历子元素并对其进行定位布局  </span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;  </div><div class="line">                <span class="comment">// 获取一个子元素  </span></div><div class="line">                View child = getChildAt(i);  </div><div class="line">      </div><div class="line">                <span class="comment">// 通知子元素进行布局  </span></div><div class="line">                child.layout(<span class="number">0</span>, mutilHeight, child.getMeasuredWidth(), </div><div class="line">                            child.getMeasuredHeight() + mutilHeight);  </div><div class="line">      </div><div class="line">                <span class="comment">// 改变高度倍增值  </span></div><div class="line">                mutilHeight += child.getMeasuredHeight();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.test.CustomLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:background</span>=<span class="string">"#FFFFFFFF"</span>  </div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">com.test.views.ImgView</span>  </span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/main_pv"</span>  </div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:padding</span>=<span class="string">"50dp"</span> /&gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">Button</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"AigeStudio"</span> /&gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"AigeStudio"</span> /&gt;  </div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">com.test.CustomLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>ViewGroup中的onLayout方法是一个抽象方法，这意味着你在继承时必须实现，onLayout的目的，是为了确定子元素在父容器中的位置，那么这个步骤，理应该由父容器来决定，而不是子元素。<br>可以看到，我们通过一个mutilHeight来存储高度倍增值，每一次子元素布局完后，将当前mutilHeight与当前子元素的高度相加，并在下一个子元素布局时，在高度上加上mutilHeight。</p>
<p>关于layout()的四个参数，如下图所示：<br><img src="http://og9cdbtvi.bkt.clouddn.com/layout.png" alt="img"></p>
<h3 id="自定义ViewGroup的padding"><a href="#自定义ViewGroup的padding" class="headerlink" title="自定义ViewGroup的padding"></a>自定义ViewGroup的padding</h3><p>给自定义的ViewGroup增加一个padding，如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.test.CustomLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:padding</span>=<span class="string">"60dp"</span>  </div><div class="line">    <span class="attr">android:background</span>=<span class="string">"#FFFFFFFF"</span>  </div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">com.test.views.ImgView</span>  </span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/main_pv"</span>  </div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:padding</span>=<span class="string">"50dp"</span> /&gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">Button</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"AigeStudio"</span> /&gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"AigeStudio"</span> /&gt;  </div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">com.test.CustomLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这个时候，运行，会发现padding把我们的子View给吃了，导致子View显示不全，那么，我们在对子元素进行定位时，应该进一步考虑到父容器内边距的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 获取父容器内边距  </span></div><div class="line">    <span class="keyword">int</span> parentPaddingLeft = getPaddingLeft();  </div><div class="line">    <span class="keyword">int</span> parentPaddingTop = getPaddingTop();  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果有子元素 </div><div class="line">     */  </div><div class="line">    <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;  </div><div class="line">        <span class="comment">// 声明一个临时变量存储高度倍增值  </span></div><div class="line">        <span class="keyword">int</span> mutilHeight = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">        <span class="comment">// 那么遍历子元素并对其进行定位布局  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;  </div><div class="line">            <span class="comment">// 获取一个子元素  </span></div><div class="line">            View child = getChildAt(i);  </div><div class="line">  </div><div class="line">            <span class="comment">// 通知子元素进行布局  </span></div><div class="line">            <span class="comment">// 此时考虑父容器内边距的影响  </span></div><div class="line">            child.layout(parentPaddingLeft, mutilHeight + parentPaddingTop,</div><div class="line">                        child.getMeasuredWidth() + parentPaddingLeft, </div><div class="line">                        child.getMeasuredHeight() + mutilHeight + parentPaddingTop);  </div><div class="line">  </div><div class="line">            <span class="comment">// 改变高度倍增值  </span></div><div class="line">            mutilHeight += child.getMeasuredHeight();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义ViewGroup的Margin"><a href="#自定义ViewGroup的Margin" class="headerlink" title="自定义ViewGroup的Margin"></a>自定义ViewGroup的Margin</h3><p>既然内边距已经可以了，我们继续试试外边距，给自定义ViewGroup增加margin，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.test.CustomLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:layout_margin</span>=<span class="string">"30dp"</span></div><div class="line">    <span class="attr">android:padding</span>=<span class="string">"60dp"</span>  </div><div class="line">    <span class="attr">android:background</span>=<span class="string">"#FFFFFFFF"</span>  </div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">com.test.views.ImgView</span>  </span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/main_pv"</span>  </div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:padding</span>=<span class="string">"50dp"</span> /&gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">Button</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"AigeStudio"</span> /&gt;  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"AigeStudio"</span> /&gt;  </div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">com.test.CustomLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们运行，发现没什么问题，但是，如果我们给我们的子View配置外边距的时候，问题就出现了，不管margin设置多大，都不起任何效果。我们在上面也说过，子View的margin应该由父容器来处理，但是我们在CustomLayout里面没有做任何处理，所以我们需要修改我们的CustomLayout。<br>我们知道，Margin是封装在LayoutParams中，而我们在ViewGroup中介绍过一个方法measureChildWithMargins()，当时我们说过：</p>
<blockquote>
<p>measureChildWithMargins要求 child 进行 Measure，在绘制的时候将自己的 padding 和 margins 考虑进去。经过 Measure 过后，可以得到对应的 LayoutParams 这个方法要求 child 必须得是 MarginLayoutParams，大部分的容器 View (LinearLayout、FrameLayout等等)都是这个 MarginLayoutParams。</p>
</blockquote>
<p>也就是说，LayoutParams必须是MarginLayoutParams，大部分容器，LinearLayout、RelativeLayout、FrameLayout等等都继承了MarginLayoutParams，所以我们需要在CustomLayout里面也使用这个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;  </div><div class="line">    <span class="comment">// 省略部分代码…………  </span></div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayoutParams</span> <span class="keyword">extends</span> <span class="title">MarginLayoutParams</span> </span>&#123;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>&#123;  </div><div class="line">            <span class="keyword">super</span>(source);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(android.view.ViewGroup.LayoutParams source)</span> </span>&#123;  </div><div class="line">            <span class="keyword">super</span>(source);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">            <span class="keyword">super</span>(c, attrs);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;  </div><div class="line">            <span class="keyword">super</span>(width, height);  </div><div class="line">        &#125;  </div><div class="line">    &#125; </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 生成默认的布局参数 </div><div class="line">     */  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> CustomLayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</div><div class="line">                            ViewGroup.LayoutParams.MATCH_PARENT);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 生成布局参数 </div><div class="line">     * 将布局参数包装成我们的 </div><div class="line">     */  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="keyword">protected</span> android.view.ViewGroup.<span class="function">LayoutParams </span></div><div class="line">            <span class="title">generateLayoutParams</span><span class="params">(android.view.ViewGroup.LayoutParams p)</span> &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(p);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 生成布局参数 </div><div class="line">     * 从属性配置中生成我们的布局参数 </div><div class="line">     */  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="keyword">public</span> android.view.ViewGroup.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutParams(getContext(), attrs);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 检查当前布局参数是否是我们定义的类型这在code声明布局参数时常常用到 </div><div class="line">     */  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(android.view.ViewGroup.LayoutParams p)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> p <span class="keyword">instanceof</span> CustomLayoutParams;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 省略部分代码…………  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>在我们的CustomLayout中生成了一个静态内部类CustomLayoutParams，保持其默认的构造方法即可，这里我们什么也没做</li>
<li>我们复写了ViewGroup里面关于LayoutParams的几个方法</li>
</ul>
<p>下面，说一下这几个方法<br>generateDefaultLayoutParams</p>
<blockquote>
<p>generateDefaultLayoutParams，生成默认布局参数，那么肯定是在没有设置的时候才会调用，在那里调用的呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</div><div class="line">        &#125;</div><div class="line">        LayoutParams params = child.getLayoutParams();</div><div class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</div><div class="line">            params = generateDefaultLayoutParams();</div><div class="line">            <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                    <span class="string">"generateDefaultLayoutParams() cannot return null"</span></div><div class="line">                    );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        addView(child, index, params);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这个也解释了，我们平常在addview的时候，即使没有设置LayoutParams，依然可以显示，就是因为如果没有，会调用父容器的generateDefaultLayoutParams生成默认的LayoutParams。</p>
<p>generateLayoutParams</p>
<blockquote>
<p>有两个重载方法，一个是在代码中主动new LayoutParams()时调用，一个是在xml里面设置的</p>
</blockquote>
<p>接下来，修改改我们的onMeasure()，考虑margin<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 声明临时变量存储父容器的期望值  </span></div><div class="line">    <span class="keyword">int</span> parentDesireWidth = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">int</span> parentDesireHeight = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果有子元素 </div><div class="line">     */  </div><div class="line">    <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;  </div><div class="line">        <span class="comment">// 那么遍历子元素并对其进行测量  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;  </div><div class="line">  </div><div class="line">            <span class="comment">// 获取子元素  </span></div><div class="line">            View child = getChildAt(i);  </div><div class="line">  </div><div class="line">            <span class="comment">// 获取子元素的布局参数  </span></div><div class="line">            CustomLayoutParams clp = (CustomLayoutParams) child.getLayoutParams();  </div><div class="line">  </div><div class="line">            <span class="comment">// 测量子元素并考虑外边距  </span></div><div class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);  </div><div class="line">  </div><div class="line">            <span class="comment">// 计算父容器的期望值  </span></div><div class="line">            parentDesireWidth += child.getMeasuredWidth() + clp.leftMargin + clp.rightMargin;  </div><div class="line">            parentDesireHeight += child.getMeasuredHeight() + clp.topMargin + clp.bottomMargin;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 考虑父容器的内边距  </span></div><div class="line">        parentDesireWidth += getPaddingLeft() + getPaddingRight();  </div><div class="line">        parentDesireHeight += getPaddingTop() + getPaddingBottom();  </div><div class="line">  </div><div class="line">        <span class="comment">// 尝试比较建议最小值和期望值的大小并取大值  </span></div><div class="line">        parentDesireWidth = Math.max(parentDesireWidth, getSuggestedMinimumWidth());  </div><div class="line">        parentDesireHeight = Math.max(parentDesireHeight, getSuggestedMinimumHeight());  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 设置最终测量值  </span></div><div class="line">    setMeasuredDimension(</div><div class="line">        resolveSize(parentDesireWidth, widthMeasureSpec), </div><div class="line">        resolveSize(parentDesireHeight, heightMeasureSpec)</div><div class="line">    );  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 获取父容器内边距  </span></div><div class="line">    <span class="keyword">int</span> parentPaddingLeft = getPaddingLeft();  </div><div class="line">    <span class="keyword">int</span> parentPaddingTop = getPaddingTop();  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果有子元素 </div><div class="line">     */  </div><div class="line">    <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;  </div><div class="line">        <span class="comment">// 声明一个临时变量存储高度倍增值  </span></div><div class="line">        <span class="keyword">int</span> mutilHeight = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">        <span class="comment">// 那么遍历子元素并对其进行定位布局  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;  </div><div class="line">            <span class="comment">// 获取一个子元素  </span></div><div class="line">            View child = getChildAt(i);  </div><div class="line">  </div><div class="line">            CustomLayoutParams clp = (CustomLayoutParams) child.getLayoutParams();  </div><div class="line">  </div><div class="line">            <span class="comment">// 通知子元素进行布局  </span></div><div class="line">            <span class="comment">// 此时考虑父容器内边距和子元素外边距的影响  </span></div><div class="line">            child.layout(parentPaddingLeft + clp.leftMargin,</div><div class="line">                    mutilHeight + parentPaddingTop + clp.topMargin,</div><div class="line">                    child.getMeasuredWidth() + parentPaddingLeft + clp.leftMargin,</div><div class="line">                    child.getMeasuredHeight() + mutilHeight + parentPaddingTop + clp.topMargin</div><div class="line">                );  </div><div class="line">  </div><div class="line">            <span class="comment">// 改变高度倍增值  </span></div><div class="line">            mutilHeight += child.getMeasuredHeight() + clp.topMargin + clp.bottomMargin;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><font color="#ff0000"> <strong><br>&emsp;&emsp;padding，都是自己来确定。自定义View，在onMeasure()和onDraw()来考虑padding；自定义ViewGroup，在onMeasure()(measureChild方法)和onLayout()时需要考虑使用padding。<br>&emsp;&emsp;margin，因为是在LayoutParams里面定义，所以都是父容器来确定。子View在自身的LayoutParams(必须为MarginLayoutParams)重设置margin，父ViewGroup在onMeasure()(measureChildWithMargins方法)和onLayout()中考虑使用margin。<br>&emsp;&emsp;基于1和2，我们可以确定，子View或子ViewGroup的getMeasuredWidth()是包含自身的padding，但是不包含自身的margin的。<br>&emsp;&emsp;一个Activity，里面是PhoneWindow，然后是DecorView，这个DecorView继承自FrameLayout，最后，才是我们自己setContentView的布局，window 的 LayoutParams 是 MATCH_PARENT, 这样 DecorView 的大小就是 Window 的大小，也就是必定是全屏的，然后把生成的MeasureSpec传递给我们的布局。
   </strong></font> </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>   <a href="http://blog.csdn.net/aigestudio/article/details/42989325" target="_blank" rel="external">自定义控件其实很简单7/12</a><br>   <a href="http://www.jianshu.com/p/afa921d8ed24" target="_blank" rel="external">Window、PhoneWindow、DecorView和android.R.id.content</a><br>   <a href="http://www.woaitqs.cc/android/2016/10/10/android-view-theory-1.html" target="_blank" rel="external">Android View 全解析(一) – 窗口管理系统</a><br>   <a href="http://www.woaitqs.cc/android/2016/10/18/android-view-theory-2" target="_blank" rel="external">Android View 全解析(二) – 窗口管理系统</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自定义View/">自定义View</a></li></ul>
	</div>

      

      

      
        <div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode"></div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2016/10/29/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Hello World</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="custom-view-measure" data-title="测量（Measure）" data-url="http://trylovecatch.github.io/2016/12/04/custom-view-measure/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"trylovecatch"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 TryLoveCatch
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/自定义View/" style="font-size: 10px;">自定义View</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">呵呵&lt;br&gt;&lt;br&gt;随便玩玩&lt;br&gt;哈哈</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>